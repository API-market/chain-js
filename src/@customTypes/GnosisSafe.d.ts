/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type AddedOwner = ContractEventLog<{
  owner: string;
  0: string;
}>;
export type ApproveHash = ContractEventLog<{
  approvedHash: string;
  owner: string;
  0: string;
  1: string;
}>;
export type ChangedMasterCopy = ContractEventLog<{
  masterCopy: string;
  0: string;
}>;
export type ChangedThreshold = ContractEventLog<{
  threshold: string;
  0: string;
}>;
export type DisabledModule = ContractEventLog<{
  module: string;
  0: string;
}>;
export type EnabledModule = ContractEventLog<{
  module: string;
  0: string;
}>;
export type ExecutionFailure = ContractEventLog<{
  txHash: string;
  payment: string;
  0: string;
  1: string;
}>;
export type ExecutionFromModuleFailure = ContractEventLog<{
  module: string;
  0: string;
}>;
export type ExecutionFromModuleSuccess = ContractEventLog<{
  module: string;
  0: string;
}>;
export type ExecutionSuccess = ContractEventLog<{
  txHash: string;
  payment: string;
  0: string;
  1: string;
}>;
export type RemovedOwner = ContractEventLog<{
  owner: string;
  0: string;
}>;
export type SignMsg = ContractEventLog<{
  msgHash: string;
  0: string;
}>;

export interface GnosisSafe extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): GnosisSafe;
  clone(): GnosisSafe;
  methods: {
    NAME(): NonPayableTransactionObject<string>;

    VERSION(): NonPayableTransactionObject<string>;

    /**
     * Allows to add a new owner to the Safe and update the threshold at the same time.      This can only be done via a Safe transaction.
     * @param _threshold New threshold.
     * @param owner New owner address.
     */
    addOwnerWithThreshold(
      owner: string,
      _threshold: number | string | BN
    ): NonPayableTransactionObject<void>;

    approvedHashes(
      arg0: string,
      arg1: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * Allows to upgrade the contract. This can only be done via a Safe transaction.
     * @param _masterCopy New contract address.
     */
    changeMasterCopy(_masterCopy: string): NonPayableTransactionObject<void>;

    /**
     * Allows to update the number of required confirmations by Safe owners.      This can only be done via a Safe transaction.
     * @param _threshold New threshold.
     */
    changeThreshold(
      _threshold: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Allows to remove a module from the whitelist.      This can only be done via a Safe transaction.
     * @param module Module to be removed.
     * @param prevModule Module that pointed to the module to be removed in the linked list
     */
    disableModule(
      prevModule: string,
      module: string
    ): NonPayableTransactionObject<void>;

    domainSeparator(): NonPayableTransactionObject<string>;

    /**
     * Allows to add a module to the whitelist.      This can only be done via a Safe transaction.
     * @param module Module to be whitelisted.
     */
    enableModule(module: string): NonPayableTransactionObject<void>;

    /**
     * Allows a Module to execute a Safe transaction without any further confirmations.
     * @param data Data payload of module transaction.
     * @param operation Operation type of module transaction.
     * @param to Destination address of module transaction.
     * @param value Ether value of module transaction.
     */
    execTransactionFromModule(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    /**
     * Allows a Module to execute a Safe transaction without any further confirmations and return data
     * @param data Data payload of module transaction.
     * @param operation Operation type of module transaction.
     * @param to Destination address of module transaction.
     * @param value Ether value of module transaction.
     */
    execTransactionFromModuleReturnData(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN
    ): NonPayableTransactionObject<{
      success: boolean;
      returnData: string;
      0: boolean;
      1: string;
    }>;

    /**
     * Returns array of first 10 modules.
     * @returns Array of modules.
     */
    getModules(): NonPayableTransactionObject<string[]>;

    /**
     * Returns array of modules.
     * @param pageSize Maximum number of modules that should be returned.
     * @param start Start of the page.
     * @returns Array of modules.
     */
    getModulesPaginated(
      start: string,
      pageSize: number | string | BN
    ): NonPayableTransactionObject<{
      array: string[];
      next: string;
      0: string[];
      1: string;
    }>;

    /**
     * Returns array of owners.
     * @returns Array of Safe owners.
     */
    getOwners(): NonPayableTransactionObject<string[]>;

    getThreshold(): NonPayableTransactionObject<string>;

    isOwner(owner: string): NonPayableTransactionObject<boolean>;

    nonce(): NonPayableTransactionObject<string>;

    /**
     * Allows to remove an owner from the Safe and update the threshold at the same time.      This can only be done via a Safe transaction.
     * @param _threshold New threshold.
     * @param owner Owner address to be removed.
     * @param prevOwner Owner that pointed to the owner to be removed in the linked list
     */
    removeOwner(
      prevOwner: string,
      owner: string,
      _threshold: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Allows to add a contract to handle fallback calls.      Only fallback calls without value and with data will be forwarded.      This can only be done via a Safe transaction.
     * @param handler contract to handle fallbacks calls.
     */
    setFallbackHandler(handler: string): NonPayableTransactionObject<void>;

    signedMessages(
      arg0: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * Allows to swap/replace an owner from the Safe with another address.      This can only be done via a Safe transaction.
     * @param newOwner New owner address.
     * @param oldOwner Owner address to be replaced.
     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list
     */
    swapOwner(
      prevOwner: string,
      oldOwner: string,
      newOwner: string
    ): NonPayableTransactionObject<void>;

    /**
     * Setup function sets initial storage of contract.
     * @param _owners List of Safe owners.
     * @param _threshold Number of required confirmations for a Safe transaction.
     * @param data Data payload for optional delegate call.
     * @param fallbackHandler Handler for fallback calls to this contract
     * @param payment Value that should be paid
     * @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)
     * @param paymentToken Token that should be used for the payment (0 is ETH)
     * @param to Contract address for optional delegate call.
     */
    setup(
      _owners: string[],
      _threshold: number | string | BN,
      to: string,
      data: string | number[],
      fallbackHandler: string,
      paymentToken: string,
      payment: number | string | BN,
      paymentReceiver: string
    ): NonPayableTransactionObject<void>;

    /**
     * Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.      Note: The fees are always transfered, even if the user transaction fails.
     * @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)
     * @param data Data payload of Safe transaction.
     * @param gasPrice Gas price that should be used for the payment calculation.
     * @param gasToken Token address (or 0 if ETH) that is used for the payment.
     * @param operation Operation type of Safe transaction.
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
     * @param safeTxGas Gas that should be used for the Safe transaction.
     * @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})
     * @param to Destination address of Safe transaction.
     * @param value Ether value of Safe transaction.
     */
    execTransaction(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN,
      safeTxGas: number | string | BN,
      baseGas: number | string | BN,
      gasPrice: number | string | BN,
      gasToken: string,
      refundReceiver: string,
      signatures: string | number[]
    ): NonPayableTransactionObject<boolean>;

    /**
     * Allows to estimate a Safe transaction.      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:      1.) The method can only be called from the safe itself      2.) The response is returned with a revert      When estimating set `from` to the address of the safe.      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`
     * @param data Data payload of Safe transaction.
     * @param operation Operation type of Safe transaction.
     * @param to Destination address of Safe transaction.
     * @param value Ether value of Safe transaction.
     * @returns Estimate without refunds and overhead fees (base transaction and payload data gas costs).
     */
    requiredTxGas(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Marks a hash as approved. This can be used to validate a hash that is used by a signature.
     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.
     */
    approveHash(
      hashToApprove: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * Marks a message as signed
     * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)
     */
    signMessage(_data: string | number[]): NonPayableTransactionObject<void>;

    /**
     * Should return whether the signature provided is valid for the provided data.      The save does not implement the interface since `checkSignatures` is not a view method.      The method will not perform any state changes (see parameters of `checkSignatures`)
     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)
     * @param _data Arbitrary length data signed on the behalf of address(this)
     * @param _signature Signature byte array associated with _data
     * @returns a bool upon valid or invalid signature with corresponding _data
     */
    isValidSignature(
      _data: string | number[],
      _signature: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * Returns hash of a message that can be signed by owners.
     * @param message Message that should be hashed
     * @returns Message hash.
     */
    getMessageHash(
      message: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * Returns the bytes that are hashed to be signed by owners.
     * @param _nonce Transaction nonce.
     * @param baseGas Gas costs for data used to trigger the safe transaction.
     * @param data Data payload.
     * @param gasPrice Maximum gas price that should be used for this transaction.
     * @param gasToken Token address (or 0 if ETH) that is used for the payment.
     * @param operation Operation type.
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
     * @param safeTxGas Fas that should be used for the safe transaction.
     * @param to Destination address.
     * @param value Ether value.
     * @returns Transaction hash bytes.
     */
    encodeTransactionData(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN,
      safeTxGas: number | string | BN,
      baseGas: number | string | BN,
      gasPrice: number | string | BN,
      gasToken: string,
      refundReceiver: string,
      _nonce: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Returns hash to be signed by owners.
     * @param _nonce Transaction nonce.
     * @param baseGas Gas costs for data used to trigger the safe transaction.
     * @param data Data payload.
     * @param gasPrice Maximum gas price that should be used for this transaction.
     * @param gasToken Token address (or 0 if ETH) that is used for the payment.
     * @param operation Operation type.
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
     * @param safeTxGas Fas that should be used for the safe transaction.
     * @param to Destination address.
     * @param value Ether value.
     * @returns Transaction hash.
     */
    getTransactionHash(
      to: string,
      value: number | string | BN,
      data: string | number[],
      operation: number | string | BN,
      safeTxGas: number | string | BN,
      baseGas: number | string | BN,
      gasPrice: number | string | BN,
      gasToken: string,
      refundReceiver: string,
      _nonce: number | string | BN
    ): NonPayableTransactionObject<string>;
  };
  events: {
    AddedOwner(cb?: Callback<AddedOwner>): EventEmitter;
    AddedOwner(options?: EventOptions, cb?: Callback<AddedOwner>): EventEmitter;

    ApproveHash(cb?: Callback<ApproveHash>): EventEmitter;
    ApproveHash(
      options?: EventOptions,
      cb?: Callback<ApproveHash>
    ): EventEmitter;

    ChangedMasterCopy(cb?: Callback<ChangedMasterCopy>): EventEmitter;
    ChangedMasterCopy(
      options?: EventOptions,
      cb?: Callback<ChangedMasterCopy>
    ): EventEmitter;

    ChangedThreshold(cb?: Callback<ChangedThreshold>): EventEmitter;
    ChangedThreshold(
      options?: EventOptions,
      cb?: Callback<ChangedThreshold>
    ): EventEmitter;

    DisabledModule(cb?: Callback<DisabledModule>): EventEmitter;
    DisabledModule(
      options?: EventOptions,
      cb?: Callback<DisabledModule>
    ): EventEmitter;

    EnabledModule(cb?: Callback<EnabledModule>): EventEmitter;
    EnabledModule(
      options?: EventOptions,
      cb?: Callback<EnabledModule>
    ): EventEmitter;

    ExecutionFailure(cb?: Callback<ExecutionFailure>): EventEmitter;
    ExecutionFailure(
      options?: EventOptions,
      cb?: Callback<ExecutionFailure>
    ): EventEmitter;

    ExecutionFromModuleFailure(
      cb?: Callback<ExecutionFromModuleFailure>
    ): EventEmitter;
    ExecutionFromModuleFailure(
      options?: EventOptions,
      cb?: Callback<ExecutionFromModuleFailure>
    ): EventEmitter;

    ExecutionFromModuleSuccess(
      cb?: Callback<ExecutionFromModuleSuccess>
    ): EventEmitter;
    ExecutionFromModuleSuccess(
      options?: EventOptions,
      cb?: Callback<ExecutionFromModuleSuccess>
    ): EventEmitter;

    ExecutionSuccess(cb?: Callback<ExecutionSuccess>): EventEmitter;
    ExecutionSuccess(
      options?: EventOptions,
      cb?: Callback<ExecutionSuccess>
    ): EventEmitter;

    RemovedOwner(cb?: Callback<RemovedOwner>): EventEmitter;
    RemovedOwner(
      options?: EventOptions,
      cb?: Callback<RemovedOwner>
    ): EventEmitter;

    SignMsg(cb?: Callback<SignMsg>): EventEmitter;
    SignMsg(options?: EventOptions, cb?: Callback<SignMsg>): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "AddedOwner", cb: Callback<AddedOwner>): void;
  once(
    event: "AddedOwner",
    options: EventOptions,
    cb: Callback<AddedOwner>
  ): void;

  once(event: "ApproveHash", cb: Callback<ApproveHash>): void;
  once(
    event: "ApproveHash",
    options: EventOptions,
    cb: Callback<ApproveHash>
  ): void;

  once(event: "ChangedMasterCopy", cb: Callback<ChangedMasterCopy>): void;
  once(
    event: "ChangedMasterCopy",
    options: EventOptions,
    cb: Callback<ChangedMasterCopy>
  ): void;

  once(event: "ChangedThreshold", cb: Callback<ChangedThreshold>): void;
  once(
    event: "ChangedThreshold",
    options: EventOptions,
    cb: Callback<ChangedThreshold>
  ): void;

  once(event: "DisabledModule", cb: Callback<DisabledModule>): void;
  once(
    event: "DisabledModule",
    options: EventOptions,
    cb: Callback<DisabledModule>
  ): void;

  once(event: "EnabledModule", cb: Callback<EnabledModule>): void;
  once(
    event: "EnabledModule",
    options: EventOptions,
    cb: Callback<EnabledModule>
  ): void;

  once(event: "ExecutionFailure", cb: Callback<ExecutionFailure>): void;
  once(
    event: "ExecutionFailure",
    options: EventOptions,
    cb: Callback<ExecutionFailure>
  ): void;

  once(
    event: "ExecutionFromModuleFailure",
    cb: Callback<ExecutionFromModuleFailure>
  ): void;
  once(
    event: "ExecutionFromModuleFailure",
    options: EventOptions,
    cb: Callback<ExecutionFromModuleFailure>
  ): void;

  once(
    event: "ExecutionFromModuleSuccess",
    cb: Callback<ExecutionFromModuleSuccess>
  ): void;
  once(
    event: "ExecutionFromModuleSuccess",
    options: EventOptions,
    cb: Callback<ExecutionFromModuleSuccess>
  ): void;

  once(event: "ExecutionSuccess", cb: Callback<ExecutionSuccess>): void;
  once(
    event: "ExecutionSuccess",
    options: EventOptions,
    cb: Callback<ExecutionSuccess>
  ): void;

  once(event: "RemovedOwner", cb: Callback<RemovedOwner>): void;
  once(
    event: "RemovedOwner",
    options: EventOptions,
    cb: Callback<RemovedOwner>
  ): void;

  once(event: "SignMsg", cb: Callback<SignMsg>): void;
  once(event: "SignMsg", options: EventOptions, cb: Callback<SignMsg>): void;
}
